= Chapter 1
Kyle Grierson<griersonky@gmail.com>
:toc:

== What is a microservice

* Independently deployable services that are modeled around a business domain
** Encapsulates functionality and that are accessible via a network
* Should have small external interfaces that rarely changes
** So implementation can change freely
** Consumers don't break
* Architecture
** Hexagonal/Ports and adapters/Onion/Clean
** Middle pure business logic
** Outside interfaces (APIS)

== Key concepts

* Independently deployable
** (Loosely coupled) Can release new/updated service without deploying other services
** Need explicit/strong/well-defined/stables contracts/interfaces between services to prevent breaking changes
* Modelled around a Business domain (DDD)
** Rolling out feature that requires changes to many services is costly
*** Need to coordinate the releases
* Prioritises high cohesion of business functionality over technical functionality
** Cohesion often refers to how the elements of a module belong together

* Don't share database
** If services share a database then they become coupled and changes need to coordinated between the two

* Size
** "Should be as big as your head" (What you find easily understood)
** As small an interface as possible

== Why

=== Composability

Business wants to reuse `user-profile` implementation for a different project

|===
| Mono | Micro

| Reuse entire project just to use the user profile implementation
| As services are small and focused they can be used in different business processes (Just tag users with new service label)
|===

[source,mermaid]
----
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
----

[plantuml]
----
@startuml
rectangle A as "Capability A"
rectangle B as "Capability B"
hexagon service

A -> service
service <- B
@enduml
----

=== Scaling

`picture` feature of website is in high demand, so you need more servers running your `picture` capability.
With monoliths you have to deploy your entire app even-though you only want to scale the `picture` capability, which comes at a higher running cost as you are paying for resources that you don't need.
Whereas with microscervices you're only paying for what you need.
|===
| Mono | Micro

a|
[plantuml]
----
@startuml
title Deploy more monoliths only to scale "picture" capability
left to right direction

frame instance1 as "Instance 1" {
    rectangle picture1 as "picture module"
    rectangle cart1 as "Cart module"
    rectangle catalog1 as "Catalog module"
    rectangle foo1 as "Foo module"
}

frame instance2 as "Instance 2" #lightgrey {
    rectangle picture2 as "picture module" #palegreen
    rectangle cart2 as "Cart module" #lightcoral
    rectangle catalog2 as "Catalog module" #lightcoral
    rectangle foo2 as "Foo module" #lightcoral
}

rectangle lb as "Load balancer"

lb --> instance1
lb --> instance2
@enduml
----

a|
[plantuml]
----
@startuml
title Deploy more picture services

left to right direction
hexagon picture1 as "Picture 1"
hexagon picture2 as "Picture 2"
hexagon picturen as "Picture N" #lightgrey
rectangle lb as "Load balancer"

lb --> picture1
lb --> picture2
lb --> picturen
@enduml
----
|===

=== Smaller (Able to use new technology)

New (library/version) comes out with new cool features that would be beneficial

|===
| Mono | Micro

a|
Stuck with previous technology choices/versions, so you have to live with when adding new features without upgrading or update entire system which may cause breaking changes
[plantuml]
----
@startuml
title Complete re-write

node s1 as "Monolith (Python 2)"
node s2 as "Monolith (Python 3)"
cloud months as "Months of development"

s1 --> months
months --> s2
@enduml
----

a|
* Can leave old services on older tech and use newer tech on new services
* Services are small so can be easily rewritten/updated with new tech

[plantuml]
----
@startuml
title Update incrementally

left to right direction

hexagon s1 as "User (Python 2)" #pink;line:red
rectangle replacement as "Toggle implementations" {
    hexagon s2 as "Cart (Python 2)" #palegreen
    hexagon s2n as "Cart (Python 3) (WIP)" #orange;line.dashed;
}
hexagon s3 as "Basket (Python 3)" #palegreen
agent Website

Website <-r- s1
Website <- replacement
Website <-l- s3
@enduml
----
|===

==== Example

Khan academy migrating from a Python 2 monolith to Go microservices as Python 2 is end of life.
If they were using microservices when Python 2 was announced to be end of life back in 2008 with an end of life in 2015. They could've started using a different language for future services and slowly migrate older services to a newer language.
https://blog.khanacademy.org/go-services-one-goliath-project/[Khan blog post about migration]

=== Fault tolerant

System crashes because of new `picture` feature

|===
| Mono | Micro

a| Entire system down
[plantuml]
----
@startuml
title Entire system down

node Monolith #pink;line:red
@enduml
----

a| Users can use rest of system just `picture` feature will be unavailable
[plantuml]
----
@startuml
title Account service is down but users can still search

left to right direction

hexagon Catalog #palegreen
hexagon Account #pink;line:red
hexagon Basket #palegreen

agent Website

Website <- Catalog
Website <-- Account
Website <-- Basket
@enduml
----
|===

== Essential tool

* Log aggregation tool
** Collect and aggregates logs from all services
** Humio, Datadog
* Trace
** Jaeger, Lightstep, Honeycomb

== Takeaways

* Pros
** Scaling, can spin up more instances for a particular service
** Upgradable, can quickly and easily start migrating to new tech
** 1 service can fail but entire system keeps running
* Cons
** Managing loads of services
** Deploying loads of services
** Learn loads of new tools for managing microservices
