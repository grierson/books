= Chapter 1
Kyle Grierson<griersonky@gmail.com>
:toc:

== Glossary

Coupling:: Dependencies

Cohesion:: Grouping dependencies that change for the same reason

== Key concepts

It's all about managing coupling and cohesion

=== Independently deployable

Must be able to make changes to a service without changing anything else so we need stable contracts between services

==== Benefits

|===
| Diagram | Benefit

a|
[plantuml]
----
@startuml
!define osaPuml https://raw.githubusercontent.com/Crashedmind/PlantUML-opensecurityarchitecture2-icons/master
!include osaPuml/Common.puml
!include osaPuml/User/all.puml

title: Independent teams

rectangle A as "Team A\n<$osa_user_large_group>" #lightcoral
rectangle B as "Team B\n<$osa_user_large_group>" #palegreen
rectangle C as "Team C\n<$osa_user_large_group>" #cornflowerblue
hexagon serviceA as "Cart"
hexagon serviceB as "Picture"
hexagon serviceC as "User"

A -D-> serviceA
B -D-> serviceB
C -D-> serviceC
@enduml
----

a| Teams can work independently of one another

* Specialise within subdomain
** "Should be as big as your head" (What you find easily understood)
* Build and deploy independently

a|
[plantuml]
----
@startuml
title: Shared database

rectangle monolitth {
    hexagon serviceA as "Service A"
    hexagon serviceB as "Service B"
}

@enduml
----

a| Service A adds

a|
[plantuml]
----
@startuml
title: All services need to be updated

hexagon serviceA as "Service A" #lightcoral
hexagon serviceB as "Service B" #lightcoral
database database as "New database"

serviceA --> database
serviceB --> database
@enduml
----
|===

==== Issues if services are not independently deployable

If services are not modelled around a Business domain (DDD)

* If a feature to spread across many services
** Coordinate releases
** Update in many places

|===
| Current | Situation | Problem

a|
[plantuml]
----
@startuml
title: Shared database

hexagon serviceA as "Service A"
hexagon serviceB as "Service B"
database database

serviceA --> database
serviceB --> database
@enduml
----

a| Database schema is updated

a|
[plantuml]
----
@startuml
title: All services need to be updated

hexagon serviceA as "Service A" #lightcoral
hexagon serviceB as "Service B" #lightcoral
database database as "New database" #palegreen

serviceA --> database
serviceB --> database
@enduml
----

a|
[plantuml]
----
@startuml
title: Basket changes

hexagon Checkout
hexagon Basket #palegreen

Basket -> Checkout
@enduml
----

a| Basket adds new feature which Checkout depends on

a|
[plantuml]
----
@startuml
title: Checkout now needs to be updated

hexagon Checkout #lightcoral
hexagon Basket

Basket -> Checkout
@enduml
----
|===

== Why

=== Composability

Business wants to reuse `user-profile` implementation for a different project

|===
| Mono | Micro

a|
[plantuml]
----
@startuml
title: You can't

node monolith #lightcoral
rectangle ProjectB as "Project B"

ProjectB -[#red,dashed,thickness=5]-> monolith
note on link
    Project B can't
end note
@enduml
----

a| As services are small and focused they can be used in different business processes
[plantuml]
----
@startuml
rectangle A as "Project A"
rectangle B as "Project B"
hexagon service

A -R-> service
service <-R- B
@enduml
----
|===

=== Scaling

`picture` feature of website is in high demand, so you need more servers running your `picture` capability.
With monoliths you have to deploy your entire app even-though you only want to scale the `picture` capability, which comes at a higher running cost as you are paying for resources that you don't need.
Whereas with microscervices you're only paying for what you need.

|===
| Mono | Micro

a|
[plantuml]
----
@startuml
title Deploy more monoliths only to scale "picture" capability
left to right direction

frame instance1 as "Instance 1" {
    rectangle picture1 as "picture module"
    rectangle cart1 as "Cart module"
    rectangle catalog1 as "Catalog module"
    rectangle foo1 as "Foo module"
}

frame instance2 as "Instance 2" #lightgrey {
    rectangle picture2 as "picture module" #palegreen
    rectangle cart2 as "Cart module" #lightcoral
    rectangle catalog2 as "Catalog module" #lightcoral
    rectangle foo2 as "Foo module" #lightcoral
}

rectangle lb as "Load balancer"

lb --> instance1
lb --> instance2
@enduml
----

a|
[plantuml]
----
@startuml
title Deploy more picture services

left to right direction
hexagon picture1 as "Picture 1"
hexagon picture2 as "Picture 2"
hexagon picturen as "Picture N" #lightgrey
rectangle lb as "Load balancer"

lb --> picture1
lb --> picture2
lb --> picturen
@enduml
----
|===

=== Smaller (Able to use new technology)

New (library/version) comes out with new cool features that would be beneficial

|===
| Mono | Micro

a|
Stuck with previous technology choices/versions, so you have to live with when adding new features without upgrading or update entire system which may cause breaking changes
[plantuml]
----
@startuml
title Complete re-write

node s1 as "Monolith (Python 2)"
node s2 as "Monolith (Python 3)"
cloud months as "Months of development"

s1 --> months
months --> s2
@enduml
----

a|
* Can leave old services on older tech and use newer tech on new services
* Services are small so can be easily rewritten/updated with new tech

[plantuml]
----
@startuml
title Update incrementally

left to right direction

hexagon s1 as "User (Python 2)" #pink;line:red
rectangle replacement as "Toggle implementations" {
    hexagon s2 as "Cart (Python 2)" #palegreen
    hexagon s2n as "Cart (Python 3) (WIP)" #orange;line.dashed;
}
hexagon s3 as "Basket (Python 3)" #palegreen
agent Website

Website <-r- s1
Website <- replacement
Website <-l- s3
@enduml
----
|===

==== Example

Khan academy migrating from a Python 2 monolith to Go microservices as Python 2 is end of life.
If they were using microservices when Python 2 was announced to be end of life back in 2008 with an end of life in 2015. They could've started using a different language for future services and slowly migrate older services to a newer language.
https://blog.khanacademy.org/go-services-one-goliath-project/[Khan blog post about migration]

=== Fault tolerant

System crashes because of new `picture` feature

|===
| Mono | Micro

a|
[plantuml]
----
@startuml
title Entire system down

node Monolith #pink;line:red
@enduml
----

a|
[plantuml]
----
@startuml
title Account service is down but users can still search

left to right direction

hexagon Catalog #palegreen
hexagon Account #pink;line:red
hexagon Basket #palegreen

agent Website

Website <- Catalog
Website <-- Account
Website <-- Basket
@enduml
----
|===

== Essential tool

* Log aggregation tool
** Collect and aggregates logs from all services
** Humio, Datadog
* Trace
** Jaeger, Lightstep, Honeycomb

== Takeaways

* Pros
** Scaling, can spin up more instances for a particular service
** Upgradable, can quickly and easily start migrating to new tech
** 1 service can fail but entire system keeps running
* Cons
** Managing loads of services
** Deploying loads of services
** Learn loads of new tools for managing microservices
