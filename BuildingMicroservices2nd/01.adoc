= Chapter 1
Kyle Grierson<griersonky@gmail.com>
:toc:

== What is a microservice

* Independently deployable services that are modeled around a business domain
** Encapsulates functionality and that are accessible via a network
* Should have small external interfaces that rarely changes
** So implementation can change freely
** Consumers don't break
* Architecture
** Hexagonal/Ports and adapters/Onion/Clean
** Middle pure business logic
** Outside interfaces (APIS)

== Key concepts

* Independently deployable
** (Loosely coupled) Can release new/updated service without deploying other services
** Need explicit/strong/well-defined/stables contracts/interfaces between services to prevent breaking changes
* Modelled around a Business domain (DDD)
** Rolling out feature that requires changes to many services is costly
*** Need to coordinate the releases
* Prioritises high cohesion of business functionality over technical functionality
** Cohesion often refers to how the elements of a module belong together

* Don't share database
** If services share a database then they become coupled and changes need to coordinated between the two

* Size
** "Should be as big as your head" (What you find easily understood)
** As small an interface as possible

== Why

=== Composability

Business wants to reuse `user-profile` implementation for a different project

|===
| Mono | Micro

| Reuse entire project just to use the user profile implementation
| As services are small and focused they can be used in different business processes (Just tag users with new service label)
|===

[source,mermaid]
----
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
----

[plantuml]
----
@startuml
rectangle A as "Capability A"
rectangle B as "Capability B"
hexagon service

A -> service
service <- B
@enduml
----

=== Scaling

`picture` feature of service is high in demand

|===
| Mono | Micro

a| Have to start up X more instances of your entire application just to support picture demand (Costly on cloud hosts)

[plantuml]
----
@startuml
title Deploy multiple monolith's just to scale "picture" capability

left to right direction
node monolith1 as "Monolith 1"
node monolith2 as "Monolith 2"
rectangle extras as "Scale up and down" {
    node monolith3 as "Monolith 3" #lightgrey
    node monolithn as "Monolith N" #lightgrey
}
node lb as "Load balancer"

lb --> monolith1
lb --> monolith2
lb --> monolith3
lb --> monolithn
@enduml
----

a|
Can scale different parts of your infrastructure Ã€ la carte.
Just start X more `picture services`

[plantuml]
----
@startuml
title Only deploy picture service instances

left to right direction
hexagon picture1 as "Picture 1"
hexagon picture2 as "Picture 2"
rectangle extras as "Scale up and down" {
    hexagon picture3 as "Picture 3" #lightgrey
    hexagon picturen as "Picture N" #lightgrey
}
node lb as "Load balancer"

lb --> picture1
lb --> picture2
lb --> picture3
lb --> picturen
@enduml
----
|===

=== Smaller (Able to use new technology)

New (library/version of currently used library) comes out with new cool features that would be beneficial

|===
| Mono | Micro

a|
Stuck with previous technology choices/versions, so you have to live with when adding new features or update entire system which may cause breaking changes
[plantuml]
----
@startuml
title Complete re-write

node s1 as "Monolith (Python 2)"
node s2 as "Monolith (Python 3)"
cloud months as "Months of development"

s1 --> months
months -> s2
@enduml
----

a|
* Can leave old services on older tech and use newer services can use latest tech
* Services are small so can be easily rewritten/updated with new tech

[plantuml]
----
@startuml
title Update incrementally

left to right direction

hexagon s1 as "User (Python 2)" #pink;line:red
rectangle replacement as "Toggle implementations" {
    hexagon s2 as "Cart (Python 2)" #lightgrey
    hexagon s2n as "Cart (Python 3)" #orange;line:black;
}
hexagon s3 as "Basket (Python 3)" #palegreen
agent Website

Website <-r- s1
Website <- replacement
Website <-l- s3
@enduml
----
|===

==== Example

Khan academy migrating from a Python 2 monolith to Go microservices as Python 2 is end of life.
If they were using microservices when Python 2 was announced to be end of life back in 2008 with an end of life in 2015. They could've started using a different language for future services and slowly migrate older services to a newer language.
https://blog.khanacademy.org/go-services-one-goliath-project/[Khan blog post about migration]

=== Fault tolerant

System crashes because of new `picture` feature

|===
| Mono | Micro

a| Entire system down
[plantuml]
----
@startuml
title Entire system down

node Monolith #pink;line:red
@enduml
----

a| Users can use rest of system just `picture` feature will be unavailable
[plantuml]
----
@startuml
title Account service is down but users can still search

left to right direction

hexagon Catalog #palegreen
hexagon Account #pink;line:red
hexagon Basket #palegreen

agent Website

Website <- Catalog
Website <-- Account
Website <-- Basket
@enduml
----
|===

== Essential tool

* Log aggregation tool
** Collect and aggregates logs from all services
** Humio, Datadog
* Trace
** Jaeger, Lightstep, Honeycomb

== Takeaways

* Pros
** Scaling, can spin up more instances for a particular service
** Upgradable, can quickly and easily start migrating to new tech
** 1 service can fail but entire system keeps running
* Cons
** Managing loads of services
** Deploying loads of services
** Learn loads of new tools for managing microservices
