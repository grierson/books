= Chapter 1
Kyle Grierson<griersonky@gmail.com>
:toc:

== What is a microservice

* Independently deployable services that are modeled around a business domain
** Encapsulates functionality and that are accessible via a network
* Should have small external interfaces that rarely changes
** So implementation can change freely
** Consumers don't break
* Architecture
** Hexagonal/Ports and adapters/Onion/Clean
** Middle pure business logic
** Outside interfaces (APIS)

== Key concepts

* Independently deployable
** (Loosely coupled) Can release new/updated service without deploying other services
** Need explicit/strong/well-defined/stables contracts/interfaces between services to prevent breaking changes
* Modelled around a Business domain (DDD)
** Rolling out feature that requires changes to many services is costly
*** Need to coordinate the releases
* Prioritises high cohesion of business functionality over technical functionality
** Cohesion often refers to how the elements of a module belong together

* Don't share database
** If services share a database then they become coupled and changes need to coordinated between the two

* Size
** "Should be as big as your head" (What you find easily understood)
** As small an interface as possible

== Why

=== Composability

Business wants to reuse `user-profile` implementation for a different project

|===
| Mono | Micro

| Reuse entire project just to use the user profile implementation
| As services are small and focused they can be used in different business processes (Just tag users with new service label)
|===

=== Scaling

`picture` feature of service is high in demand

|===
| Mono | Micro

| Have to start up X more instances of your entire application just to support picture demand (Costly on cloud hosts)

a|
Can scale different parts of your infrastructure Ã€ la carte.
Just start X more `picture services`
|===

=== Smaller (Able to use new technology)

New (library/version of currently used library) comes out with new cool features that would be beneficial

|===
| Mono | Micro

a| Stuck with previous technology choices/versions, so you have to live with when adding new features or update entire system which may cause breaking changes

a|
* Can leave old services on older tech and use newer services can use latest tech
* Services are small so can be easily rewritten/updated with new tech
|===

==== Example

Khan academy migrating from a Python 2 monolith to Go microservices as Python 2 is end of life.
If they were using microservices when Python 2 was announced to be end of life back in 2008 with an end of life in 2015. They could've started using a different language for future services and slowly migrate older services to a newer language.
https://blog.khanacademy.org/go-services-one-goliath-project/[Khan blog post about migration]

=== Fault tolerant

System crashes because of new `picture` feature

==== Mono

Entire system down

==== Micro

Users can use rest of system just `picture` feature will be unavailable

== Essential tool

* Log aggregation tool
** Collect and aggregates logs from all services
** Humio, Datadog
* Trace
** Jaeger, Lightstep, Honeycomb

== Takeaways

* Pros
** Scaling, can spin up more instances for a particular service
** 1 service can fail but entire system keeps running
* Cons
** Managing loads of services
** Deploying loads of services
** Learn loads of new tools for managing microservices