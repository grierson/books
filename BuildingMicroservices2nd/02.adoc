= Chapter 2 - Model Microservices

"A structure is table if cohesion isstring and coupling is low"

== Glossary

Information hiding (Encapsulation)::
Expose as little implementation details through your api.
Can change implementation without breaking consumers

Cohesion - relationship of things within a microservice ::
The code that changes together, stays together.
Group things that change for the same reasons.
Separate those things that change for different reasons.

Coupling - relationship with other microservices ::
Loosely coupled changes to one service should not **require** changes to another.
I can add new features to one service, but I can optionally choose to update another service to use that new feature, but I'm not required too.

== Desired design

* Services can be created in parallel as communicate via interfaces and by implementation details
* Smaller and easier to comprehend.
* Flexibility
** Services can be changed independently
** Services can be combined in different ways for different future business requirements

== Types of Coupling

.Loose coupling -> tight coupling
[graphviz]
----
graph name {
    rankdir="LR"
    Domain --  "Pass-through" -- Common -- Content
}
----

== Domain coupling

`Order processor` is coupled to `Warehouse` and `Payment` in order to process orders which is unavoidable.

WARNING: If a service is coupled to many services then it's a sign that it's doing too much.
Violates Single responsibility

[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse
hexagon Payment

Order --> Warehouse : Reserve stock
Order --> Payment : Take payment
@enduml
----

=== Temporal coupling

If `Order Processor` called `Warehouse` directly but it currently down then `Processing Orders` would fail

.Sync calls
[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse #lightcoral

Order --> Warehouse : Reserve stock
@enduml
----

However, If we had a queue in-between then events would be saved and could be processed later once warehouse is up and running again

.Async calls
[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse #lightcoral
queue Stock as "Stock Topic"

Order --> Stock : Reserve stock event
Stock --> Warehouse : Consume reserve stock event
@enduml
----

== Pass-through

`Order processor` is including data for `Shipping` because it *knows* `Warehouse` calls `Shipping`

[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse
hexagon Shipping

Order --> Warehouse : Send order request
note on link
    Includes Shipping Manifest
end note
Warehouse --> Shipping : Take payment
note on link
    Requires Shipping Manifest
end note
@enduml
----

One option is to bypass the middle man (`Warehouse`).
However, this now means `Order processing` as to

. Have domain coupling with `Shipping`
. Manage `reserving` and `removing` stock from the warehouse

[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse
hexagon Shipping

Order -> Warehouse : (1) Reserve stock
Order -> Shipping : (2) Shipping manifest
Order --> Warehouse : (3) Remove stock
@enduml
----

Another option is to have `Warehouse` create the `Shipping manifest`.
However `Order processor` would have to be updated if `Warehouse` required more data to generate the `Shipping manifest`

[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse
hexagon Shipping

Order --> Warehouse : Send order request\n(Contains data needed to create a Shipping manifest)
Warehouse --> Shipping : Dispatch package request\n w\Generated Shipping manifest
@enduml
----

A final option is to use `hypermedia links`. `Warehouse` knows nothing about the structure of the `Shipping manifest`.
It just passes the `link` to the data on to the `Shipping`.
If `Shipping` requires the data in a different format then we only need to update `Order` (Producer) and `Shipping` (Consumer)

[plantuml]
----
@startuml
left to right direction

hexagon Order as "Order Processor"
hexagon Warehouse
hexagon Shipping

Order --> Warehouse : Send order request\n(Contains Shipping manifest link)
Warehouse --> Shipping : Take payment
Shipping --> Order : Get shipping manifest
@enduml
----

== Common Coupling

Problem can occur if multiple services share a database

[plantuml]
----
@startuml

hexagon Order as "Order Processor"
hexagon Warehouse
database Country

Order --> Country
Warehouse --> Country
@enduml
----

The state machine below shows the transitions that an order should go through.
However, if multiple services are updating the state they need to be coordinated to ensure no bad states occur.

.State transitions for an order
[plantuml]
----
@startuml
left to right direction
hide empty description

[*] --> PLACED
PLACED --> PAID
PLACED --> CANCELED
PAID --> PICKING
PAID --> CANCELED
PICKING --> CANCELED
PICKING --> SHIPPED
@enduml
----

One solution is to create a coordinator 'Order service' who can accept/reject requests to update the state.

[plantuml]
----
@startuml
left to right direction

hexagon OrderProc as "Order Processor service"
hexagon Warehouse as "Warehouse service"
file "Order microservice" #line.dashed; {
    hexagon Order as "Order service"
    database OrderDB as "Order table"
}

Order --> OrderDB

OrderProc --> Order : PLACED || PAID requests
Warehouse --> Order : PICKING || SHIPPED requests
@enduml
----

== Content coupling

